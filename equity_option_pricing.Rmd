---
title: "pricing equity options"
author: "mdowns"
date: "November 04, 2015"
output:
  pdf_document:
    latex_engine: xelatex
---

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='hide',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=5}
library(xts)
library(urca)
library(quantmod)
library(fUnitRoots)
library(PerformanceAnalytics)
library(highfrequency)
library(fOptions)
library(optimx)
#library(timeSeries)
#library(timeDate)

#library(lubridate)
#library(tseries)
#library(TTR)
#library(caret)
#library(mondate)
#library(MTS)
#library(car)

```

## problem 2
Take a 3 month European call option on an underlying asset S modeled by geometric Brownian motion and use the following parameters: 
initial price S0 = 50, rate of return $\mu$= 10%, volatility $\sigma$ = 30%, interest rate r = 5%, strike K = 50, expiration T = 0.25.

*(a) By using Monte-Carlo estimator, give an estimate of this call option with a 95% confidence interval.*

The estimate of the call option price is: 

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

library(fOptions)

# given
K=50
ttm=0.25
delta.t=1/360
path.len=ttm/delta.t
S_0=50
r=0.05
sigma=0.3
mu=0.1
div=0

# function to generate paths based on rnorm()
norm_path=function(S_0,ttm,sigma,path.len){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]*(1+rnorm(1,0,sigma/path.len)) # sqrt(ttm/path.len)
     }
     return(S_1.vals)
}

# function to calculate black-sholes option value based on path of underlying
bsCallVal=function(sigma,r,div,K,ttm,S){
     
     d1=(log(S/K)+(r-div+sigma^2/2)*(ttm))/(sigma*sqrt(ttm))
     d2=d1-sigma*sqrt(ttm)
     pC=S*exp(-div*ttm)*pnorm(d1)-K*exp(-r*ttm)*pnorm(d2)

     return(pC)
}

# looping to find sigma.ci and, therefore, N.ci
end.c=NULL
for(i in 1:100){
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     end.s=s.vals.norm[length(s.vals.norm)]
     end.c[i]=bsCallVal(sigma,r,div,K,ttm,end.s)
}
sigma.ci=sd(end.c)

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2)

end.c.norm=NULL
for(i in 1:N.ci){ 
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     end.s=s.vals.norm[length(s.vals.norm)]
     end.c.norm[i]=bsCallVal(sigma,r,div,K,ttm,end.s)
}
mean(end.c.norm)
```

Based on an intial sample of 100 pricings that yielded a 0.87 standard deviation, the final mean estimate was based on 1200 iterations. The 95% confidence interval around the estimate is:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=5}

mean(end.c.norm)+qnorm(0.95)*sd(end.c.norm);mean(end.c.norm)-qnorm(0.95)*sd(end.c.norm)
par(mfrow=c(1,1));hist(end.c.norm)
abline(v=mean(end.c.norm),lwd=2,col="black");
abline(v=mean(end.c.norm)+qnorm(0.95)*sd(end.c.norm),col="red",lwd=2)
abline(v=mean(end.c.norm)-qnorm(0.95)*sd(end.c.norm),col="red",lwd=2)

```

\textbf{comments:}

The figure below shows example monte carlo paths generated by the pricing algorithm. 

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=5}

par(mfrow=c(1,1))
plot(norm_path(S_0,ttm,sigma,path.len),type="l",ylim=c(45,55),main="monte-carlo path examples")
lines(norm_path(S_0,ttm,sigma,path.len),col="red")
lines(norm_path(S_0,ttm,sigma,path.len),col="blue")

```

I validate the results by: 1. fitting a monte carlo option valuation model using sobol rnorm innovations, a Weiner path and black-scholes. That model estimated a call option value of $3.29. The graphic below, shows the call valuations as the model burns in.

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=5}

## 1. first using fOptions monte carlo simulator
sobolInnovations = function(mcSteps, pathLength, init, ...) {
     innovations = rnorm.sobol(mcSteps, pathLength, init, ...)
     # return
     innovations }

wienerPath = function(eps) { 
     # generate paths
     path = (b-sigma*sigma/2)*delta.t + sigma*sqrt(delta.t)*eps
     # return
     path }

plainVanillaPayoff = function(path) { 
     # compute payoff value
     ST = S*exp(sum(path))
     if (TypeFlag == "c") payoff = exp(-r*Time)*max(ST-X, 0)
     if (TypeFlag == "p") payoff = exp(-r*Time)*max(0, X-ST)
     # return
     payoff }

TypeFlag <<- "c"; S <<- 50; X <<- 50; Time <<- 0.25; sigma <<- 0.3; r <<- 0.05; b <<- r

mc = MonteCarloOption(delta.t = 1/360, pathLength = floor(Time/delta.t), mcSteps = 5000, 
     mcLoops = 50, init = TRUE, innovations.gen = sobolInnovations, 
     path.gen = wienerPath, payoff.calc = plainVanillaPayoff, 
     antithetic = TRUE, standardization = FALSE, trace = FALSE, 
     scrambling = 2, seed = 4711)

par(mfrow = c(1, 1))
mcPrice = cumsum(mc)/(1:length(mc))
plot(mcPrice, type = "l", main = "Plain Vanilla Call Option", xlab = "Monte Carlo Loops", ylab = "Option Price") 
```

2. Using the closed-form black-scholes estimation code producing the same $3.29 call value estimate:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

## 2. using black-sholes formula
d1=(log(S_0/K)+(r-div+sigma^2/2)*(ttm))/(sigma*sqrt(ttm))
d2=d1-sigma*sqrt(ttm)
S_0*exp(-div*ttm)*pnorm(d1)-K*exp(-r*ttm)*pnorm(d2)

```

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

#******** implementation code
# function to generate paths based on rnorm()
norm_path=function(S_0,ttm,sigma,path.len){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]*(1+rnorm(1,0,sigma/path.len)) # sqrt(ttm/path.len)
     }
     return(S_1.vals)
}

# function to calculate black-sholes option value based on path of underlying
bsCallVal=function(sigma,r,div,K,ttm,S){
     
     d1=(log(S/K)+(r-div+sigma^2/2)*(ttm))/(sigma*sqrt(ttm))
     d2=d1-sigma*sqrt(ttm)
     pC=S*exp(-div*ttm)*pnorm(d1)-K*exp(-r*ttm)*pnorm(d2)

     return(pC)
}

# looping to find sigma.ci and, therefore, N.ci
end.c=NULL
for(i in 1:100){
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     end.s=s.vals.norm[length(s.vals.norm)]
     end.c[i]=bsCallVal(sigma,r,div,K,ttm,end.s)
}
sigma.ci=sd(end.c)

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2)

end.c.norm=NULL
for(i in 1:N.ci){ 
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     end.s=s.vals.norm[length(s.vals.norm)]
     end.c.norm[i]=bsCallVal(sigma,r,div,K,ttm,end.s)
}

#********** validation code
## 1. first using fOptions monte carlo simulator
sobolInnovations = function(mcSteps, pathLength, init, ...) {
     innovations = rnorm.sobol(mcSteps, pathLength, init, ...)
     # return
     innovations }

wienerPath = function(eps) { 
     # generate paths
     path = (b-sigma*sigma/2)*delta.t + sigma*sqrt(delta.t)*eps
     # return
     path }

plainVanillaPayoff = function(path) { 
     # compute payoff value
     ST = S*exp(sum(path))
     if (TypeFlag == "c") payoff = exp(-r*Time)*max(ST-X, 0)
     if (TypeFlag == "p") payoff = exp(-r*Time)*max(0, X-ST)
     # return
     payoff }

TypeFlag <<- "c"; S <<- 50; X <<- 50; Time <<- 0.25; sigma <<- 0.3; r <<- 0.05; b <<- r

mc = MonteCarloOption(delta.t = 1/360, pathLength = floor(Time/delta.t), mcSteps = 5000, 
     mcLoops = 50, init = TRUE, innovations.gen = sobolInnovations, 
     path.gen = wienerPath, payoff.calc = plainVanillaPayoff, 
     antithetic = TRUE, standardization = FALSE, trace = FALSE, 
     scrambling = 2, seed = 4711)

par(mfrow = c(1, 1))
mcPrice = cumsum(mc)/(1:length(mc))
plot(mcPrice, type = "l", main = "Plain Vanilla Call Option", xlab = "Monte Carlo Loops", ylab = "Option Price") 

## 2. using black-sholes formula
d1=(log(S_0/K)+(r-div+sigma^2/2)*(ttm))/(sigma*sqrt(ttm))
d2=d1-sigma*sqrt(ttm)
S_0*exp(-div*ttm)*pnorm(d1)-K*exp(-r*ttm)*pnorm(d2)

```


*(b) Given the underlying has a CEV process ($dS_t=S_t(\mu dt + \alpha S_t^\beta dW_t)$, $\beta = âˆ’0.8$ and $\alpha S_0 \beta =0.3$, $Z_i \sim N(0,T/N)$), use Monte-Carlo to estimate call price at 95% ci.*

Using monte carlo and cev, I estimate the value of the call option to be:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# given
beta=-0.8
alphaS_0beta=0.3
alpha=0.3/(S_0^beta)
mu=r

# function for generating discretized paths
discret_base=function(S_0,mu,ttm,path.len,alpha,beta){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]*(1+mu*ttm/path.len+alpha*S_0^beta*rnorm(1,0,sqrt(ttm/path.len))) # sigma/path.len
     }
     return(S_1.vals)
}

# function for calculating CEV payoff
cevCallVal=function(sigma,r,alpha,div,K,ttm,S,beta){
     
     v=((sigma^2)/
          (2*(r-div)*(alpha-1))) *
          (exp(2*(r-div)*(alpha-1)*(ttm))-1)
     
     a=((K*exp(-(r-div)*ttm))^(2*beta)) /
          ((beta)^2*v)
     
     b=1/(1-beta)
     
     c_parm=(S^(-2*beta))/(((beta)^2)*v)
     
     if(beta>-1 && beta<0){
          pC = (S*exp(-div*ttm) * (1-pchisq(a,b+2,c_parm))) -
               (K*exp(-r*ttm) * (pchisq(c_parm,b,a)))
     } else if(beta>0){
          pC = (S*exp(-div*ttm) * (1-pchisq(c_parm,-b,a))) -
               (K*exp(-r*ttm) * (pchisq(a,2-b,c_parm)))
     }
     return(pC)
}

end.c.norm=NULL
for(i in 1:N.ci){ 
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     end.s=s.vals.norm[length(s.vals.norm)]
     end.c.norm[i]=bsCallVal(sigma,r,div,K,ttm,end.s)
}
#mean(end.c.norm)

# looping to find sigma.ci and, therefore, N.ci
end.discret.cev=end.norm.cev=end.norm.bs=end.discret.bs=NULL
for(i in 1:100){
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     s.vals.discret=discret_base(S_0,mu,ttm,path.len,alpha,beta)
     
     end.s.norm=s.vals.norm[length(s.vals.norm)]
     end.s.discret=s.vals.discret[length(s.vals.discret)]
     
     end.norm.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.norm)
     end.discret.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.discret)
     
     end.norm.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.norm,beta)
     end.discret.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.discret,beta)
}
sigma.ci=max(sd(end.discret.bs),sd(end.discret.cev))

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2)

end.discret.cev=end.norm.cev=end.norm.bs=end.discret.bs=NULL
for(i in 1:N.ci){
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     s.vals.discret=discret_base(S_0,mu,ttm,path.len,alpha,beta)
     
     end.s.norm=s.vals.norm[length(s.vals.norm)]
     end.s.discret=s.vals.discret[length(s.vals.discret)]
     
     end.norm.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.norm)
     end.discret.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.discret)
     
     end.norm.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.norm,beta)
     end.discret.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.discret,beta)
}

mean(end.discret.cev)

```

\textbf{comments:}

I tested several approches combining random normal and discretized paths with black-scholes and cev put valuation methods. Histograms of results are below.

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=5,fig.width=7}

par(mfrow=c(2,2))
hist(end.norm.bs);abline(v=mean(end.norm.bs),lwd=2,col="red",main="call value: black-sholes / normal")
hist(end.discret.bs);abline(v=mean(end.discret.bs),lwd=2,col="red",main="call value: black-sholes / discretized")
hist(end.norm.cev);abline(v=mean(end.norm.cev),lwd=2,col="red",main="call value: cev / normal")
hist(end.discret.cev);abline(v=mean(end.discret.cev),lwd=2,col="red",main="call value: cev / discretized")

```

Looping thru 100 records, then taking the standard deviation of the process, I found a "N" of found standard deviation of process and required "N" of 90,000 was required to cover all scenarios. An example set of cet paths are shown below. 

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=5}

par(mfrow=c(1,1))
plot(discret_base(S_0,mu,ttm,path.len,alpha,beta),type="l",ylim=c(30,70),main="cev discretization example paths")
lines(discret_base(S_0,mu,ttm,path.len,alpha,beta),col="red")
lines(discret_base(S_0,mu,ttm,path.len,alpha,beta),col="blue")

```

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# function for generating discretized paths
discret_base=function(S_0,mu,ttm,path.len,alpha,beta){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]*(1+mu*ttm/path.len+alpha*S_0^beta*rnorm(1,0,sqrt(ttm/path.len))) # sigma/path.len
     }
     return(S_1.vals)
}

# function for calculating CEV payoff
cevCallVal=function(sigma,r,alpha,div,K,ttm,S,beta){
     
     v=((sigma^2)/
          (2*(r-div)*(alpha-1))) *
          (exp(2*(r-div)*(alpha-1)*(ttm))-1)
     
     a=((K*exp(-(r-div)*ttm))^(2*beta)) /
          ((beta)^2*v)
     
     b=1/(1-beta)
     
     c_parm=(S^(-2*beta))/(((beta)^2)*v)
     
     if(beta>-1 && beta<0){
          pC = (S*exp(-div*ttm) * (1-pchisq(a,b+2,c_parm))) -
               (K*exp(-r*ttm) * (pchisq(c_parm,b,a)))
     } else if(beta>0){
          pC = (S*exp(-div*ttm) * (1-pchisq(c_parm,-b,a))) -
               (K*exp(-r*ttm) * (pchisq(a,2-b,c_parm)))
     }
     return(pC)
}

end.c.norm=NULL
for(i in 1:N.ci){ 
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     end.s=s.vals.norm[length(s.vals.norm)]
     end.c.norm[i]=bsCallVal(sigma,r,div,K,ttm,end.s)
}
#mean(end.c.norm)

# looping to find sigma.ci and, therefore, N.ci
end.discret.cev=end.norm.cev=end.norm.bs=end.discret.bs=NULL
for(i in 1:100){
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     s.vals.discret=discret_base(S_0,mu,ttm,path.len,alpha,beta)
     
     end.s.norm=s.vals.norm[length(s.vals.norm)]
     end.s.discret=s.vals.discret[length(s.vals.discret)]
     
     end.norm.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.norm)
     end.discret.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.discret)
     
     end.norm.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.norm,beta)
     end.discret.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.discret,beta)
}
sigma.ci=max(sd(end.discret.bs),sd(end.discret.cev))

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2)

end.discret.cev=end.norm.cev=end.norm.bs=end.discret.bs=NULL
for(i in 1:N.ci){
     s.vals.norm=norm_path(S_0,ttm,sigma,path.len)
     s.vals.discret=discret_base(S_0,mu,ttm,path.len,alpha,beta)
     
     end.s.norm=s.vals.norm[length(s.vals.norm)]
     end.s.discret=s.vals.discret[length(s.vals.discret)]
     
     end.norm.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.norm)
     end.discret.bs[i]=bsCallVal(sigma,r,div,K,ttm,end.s.discret)
     
     end.norm.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.norm,beta)
     end.discret.cev[i]=cevCallVal(alphaS_0beta,r,alpha,div,K,ttm,end.s.discret,beta)
}

```


## problem 3
*An Up-and-Out Put option (UOP for short) with strike K and barrier level H has the same payoff at time T as a vanilla put option: (K âˆ’ ST )+, unless the stock went above the barrier level H during the life of the option, in which case, the holder receives nothing.*

*(a) Is such an option cheaper or more expensive than a put option without barrier?*

Assuming no rebate, an up and out option will be cheaper than a vanilla put given the higher probability that it expires worthless given the "knock out" potential. As we'll see below, that probability increment (quantified in "e" below) is a function of the $ distance to the barrier and the T distance to option maturity as well as assumptions made about the underlying distribution.

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}
library(fExoticOptions)
# given
S0 = 50; K = 60; sigma = 0.3; ttm = 0.25; r = 0.05; H = 55; N = 63; 
alpha.ci=0.05; rebate=0; div=0
delta.t=1/254; path.len=ttm/delta.t

```

*(b) By discretizing at times ti = iT/N for i = 1,...,N, find an estimator for the price of this option.*

To illustrate the estimator, I'll use data from part "c". That option starts w/ $10 of potential value ($60 strike - $50 current price). Any ending below $55 pays out, so long as the stock stayed below $55 during the life of the option. So, an estimator of value for that option would need to: 1. quantify the portion of potential paths that go above $55 at any point, 2. assign a value of $0 to them, and 3. assign the discounted value of (K-S_t)) to the remaining paths.

I estimated the value of the option under this approach using the euler discretization scheme for Black-Scholes: $S_{t+dt}=S_idt+\mu S_{tdt} dt + \sigma S_{idt} \sqrt(dt)Z_i$. With 76% of paths successful (not knocked-out), the estimated put value is:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# euler scheme
discret_euler=function(S_0,r,sigma,ttm,path.len){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]+r*S_1.vals[i]*(ttm/path.len)+
               sigma*S_1.vals[i]*sqrt(ttm)*rnorm(1,0,sqrt(sigma/path.len))
     }
     return(S_1.vals)
}

end.euler=NULL
for(i in 1:1000){
     s.vals.euler=discret_euler(S0,r,sigma,ttm,path.len)
     if(max(s.vals.euler)<55){end.euler[i]=s.vals.euler[length(s.vals.euler)]}
     else(end.euler[i]=NA)
}
success.paths=sum(!is.na(end.euler))/1000;#success.paths
exp(-r*ttm)*success.paths*(K-mean(end.euler,na.rm=T))

```

I then use the Milstein Scheme for Black-Scholes: $S_{t+dt}=S_idt+\mu S_{tdt} dt + \sigma S_{idt} \sqrt(dt)Z_i + sigma^2 S_{idt} \frac{dt}{2}(Z_i^2-1)$. With 77% successful paths, the estimated put value using Milstein is:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# milstein scheme
discret_milstein=function(S_0,r,sigma,ttm,path.len){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]+r*S_1.vals[i]*(ttm/path.len)+
               sigma*S_1.vals[i]*sqrt(ttm)*rnorm(1,0,sqrt(sigma/path.len))+
               sigma^2*S_1.vals[i]*(delta.t/2)*(rnorm(1,0,sqrt(sigma/path.len))^2-1)
     }
     return(S_1.vals)
}

end.milstein=NULL
for(i in 1:1000){
     s.vals.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     if(max(s.vals.milstein)<55){end.milstein[i]=s.vals.milstein[length(s.vals.milstein)]}
     else(end.milstein[i]=NA)
}
success.paths=sum(!is.na(end.milstein))/1000;#success.paths
exp(-r*ttm)*success.paths*(K-mean(end.milstein,na.rm=T))

```

\textbf{comments:}

The graphics below show example Euler and Milstein paths from the analysis with knock-out barrier highlighted in red:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=7}
par(mfrow=c(1,2))

plot(discret_euler(S0,r,sigma,ttm,path.len),type="l",ylim=c(40,60),main="euler example paths")
lines(discret_euler(S0,r,sigma,ttm,path.len),col="red")
lines(discret_euler(S0,r,sigma,ttm,path.len),col="blue")
abline(h=55,lwd=2,col="red")

plot(discret_milstein(S0,r,sigma,ttm,path.len),type="l",ylim=c(40,60),main="milstein example paths")
lines(discret_milstein(S0,r,sigma,ttm,path.len),col="red")
lines(discret_milstein(S0,r,sigma,ttm,path.len),col="blue")
abline(h=55,lwd=2,col="red")

```

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# euler scheme
discret_euler=function(S_0,r,sigma,ttm,path.len){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]+r*S_1.vals[i]*(ttm/path.len)+
               sigma*S_1.vals[i]*sqrt(ttm)*rnorm(1,0,sqrt(sigma/path.len))
     }
     return(S_1.vals)
}

end.euler=NULL
for(i in 1:1000){
     s.vals.euler=discret_euler(S0,r,sigma,ttm,path.len)
     if(max(s.vals.euler)<55){end.euler[i]=s.vals.euler[length(s.vals.euler)]}
     else(end.euler[i]=NA)
}
success.paths=sum(!is.na(end.euler))/1000;#success.paths
exp(-r*ttm)*success.paths*(K-mean(end.euler,na.rm=T))

# milstein scheme
discret_milstein=function(S_0,r,sigma,ttm,path.len){
     S_1.vals=S_0
     for(i in 1:path.len){
          S_1.vals[i+1]=S_1.vals[i]+r*S_1.vals[i]*(ttm/path.len)+
               sigma*S_1.vals[i]*sqrt(ttm)*rnorm(1,0,sqrt(sigma/path.len))+
               sigma^2*S_1.vals[i]*(delta.t/2)*(rnorm(1,0,sqrt(sigma/path.len))^2-1)
     }
     return(S_1.vals)
}

end.milstein=NULL
for(i in 1:1000){
     s.vals.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     if(max(s.vals.milstein)<55){end.milstein[i]=s.vals.milstein[length(s.vals.milstein)]}
     else(end.milstein[i]=NA)
}
success.paths=sum(!is.na(end.milstein))/1000;#success.paths
exp(-r*ttm)*success.paths*(K-mean(end.milstein,na.rm=T))

```


*(c) The price of the stock is assumed to follow the Black-Scholes model. Take the following parameters: initial price S0 = 50, strike K = 60, volatility $\sigma$ = 30%, expiration T = 0.25, interest rate r = 5%, barrier H = 55, discretization step N = 63. Compute an estimate of the price and give a 95% confidence interval.*

Discounted estimates using black scholes, the two discretization schemes and the manual knock-out implementation where knock-out paths are assigned $0 value are $8 for Euler and $8.7 for Milstein. The 95% confidence interval for these estimates are below beginning with Euler:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# function to calculate black-sholes put option value based on path of underlying
bsPutVal=function(sigma,r,div,K,ttm,S){
     
     d1=(log(S/K)+(r-div+sigma^2/2)*(ttm))/(sigma*sqrt(ttm))
     d2=d1-sigma*sqrt(ttm)
     pC=K*exp(-r*ttm)*pnorm(-d2)-S*exp(-div*ttm)*pnorm(-d1)

     return(pC)
}

# looping to find sigma.ci and, therefore, N.ci
end.euler.bs=end.milstein.bs=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=0)
     
     if(max(s.discret.milstein)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=0)     
}
sigma.ci=max(sd(end.euler.bs,na.rm=T),sd(end.milstein.bs,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bs=end.milstein.bs=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=0)
     
     if(max(s.discret.milstein)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=0)     
}

# discretized bs estimates
#exp(-r*ttm)*mean(end.euler.bs,na.rm=T); exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)

exp(-r*ttm)*mean(end.euler.bs,na.rm=T)+qnorm(0.95)*sd(end.euler.bs,na.rm=T)
exp(-r*ttm)*mean(end.euler.bs,na.rm=T)-qnorm(0.95)*sd(end.euler.bs,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)+qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)-qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)

```

*Is the estimate biased? Is it biased low or high?*

The barrier estimate using fExoticOptions is $6.9. The Euler estimate is +16%. The Milstein estimate is +26%. Both estimates are biased high missing by an average 21%.

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='hide',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

rebate=0
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```

\textbf{comments:}

Estimates were derived by first running 100 MC iterations, finding the standard deviation (5.6), then running $N=48,000$ iterations. Graphics below show the dispersion of estimates.

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=6}

par(mfrow=c(1,2))
hist(exp(-r*ttm)*end.euler.bs,main="euler")
abline(v=exp(-r*ttm)*mean(end.euler.bs),lwd=2,col="red",main="Euler put value est")

hist(exp(-r*ttm)*end.milstein.bs,main="milstein")
abline(v=exp(-r*ttm)*mean(end.milstein.bs),lwd=2,col="red",main="Milstein put value est")

```

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

#********** implementation code
# function to calculate black-sholes put option value based on path of underlying
bsPutVal=function(sigma,r,div,K,ttm,S){
     
     d1=(log(S/K)+(r-div+sigma^2/2)*(ttm))/(sigma*sqrt(ttm))
     d2=d1-sigma*sqrt(ttm)
     pC=K*exp(-r*ttm)*pnorm(-d2)-S*exp(-div*ttm)*pnorm(-d1)

     return(pC)
}

# looping to find sigma.ci and, therefore, N.ci
end.euler.bs=end.milstein.bs=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=0)
     
     if(max(s.discret.milstein)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=0)     
}
sigma.ci=max(sd(end.euler.bs,na.rm=T),sd(end.milstein.bs,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bs=end.milstein.bs=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=0)
     
     if(max(s.discret.milstein)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=0)     
}

# discretized bs estimates
#exp(-r*ttm)*mean(end.euler.bs,na.rm=T); exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)

exp(-r*ttm)*mean(end.euler.bs,na.rm=T)+qnorm(0.95)*sd(end.euler.bs,na.rm=T)
exp(-r*ttm)*mean(end.euler.bs,na.rm=T)-qnorm(0.95)*sd(end.euler.bs,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)+qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)-qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)

#********** validation code
rebate=0
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```


*(d) An Up-and-Out Put option with a rebate pays its holder a rebate at the time at which the option is knocked out. Suppose the rebate is USD 5. Compute an estimate of the price together with a 95% confidence interval.*

I updated the prior model to set knock-out paths equal to the $5 rebate value. New discounted estimates are Euler: $9.2, Milstein: $8.6. The confidence intervals are below starting with Euler.

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

end.euler.bs=end.milstein.bs=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=5)
     
     if(max(s.discret.euler)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=5)     
}
sigma.ci=max(sd(end.euler.bs,na.rm=T),sd(end.milstein.bs,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bs=end.milstein.bs=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=5)
     
     if(max(s.discret.euler)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=5)     
}

# discretized bs confidence intervals
exp(-r*ttm)*mean(end.euler.bs,na.rm=T)+qnorm(0.95)*sd(exp(-r*ttm)*end.euler.bs,na.rm=T)
exp(-r*ttm)*mean(end.euler.bs,na.rm=T)-qnorm(0.95)*sd(exp(-r*ttm)*end.euler.bs,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)+qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)-qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)

```

*Is the estimate biased? Is it biased low or high?*

The barrier with rebate estimate using fExoticOptions is: $9.5. So, while both my estimates and the package estimates have moved up to reflect the value of the rebate, the relationship has flipped. My estimates are now below (biased low) the package estimates. 

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='hide',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

rebate=5
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```

\textbf{comments:}

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=3.5,fig.width=6}

par(mfrow=c(1,2))
hist(exp(-r*ttm)*end.euler.bs,main="Euler put value est");
abline(v=exp(-r*ttm)*mean(end.euler.bs),lwd=2,col="red")

hist(exp(-r*ttm)*end.milstein.bs,main="Milstein put value est");
abline(v=exp(-r*ttm)*mean(end.milstein.bs),lwd=2,col="red")

```

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

#************** implementation code
end.euler.bs=end.milstein.bs=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=5)
     
     if(max(s.discret.euler)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=5)     
}
sigma.ci=max(sd(end.euler.bs,na.rm=T),sd(end.milstein.bs,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bs=end.milstein.bs=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.euler)
     }
     else(end.euler.bs[i]=5)
     
     if(max(s.discret.euler)<55){
          end.s.milstein=s.discret.milstein[length(s.discret.milstein)]
          end.milstein.bs[i]=bsPutVal(sigma,r,div,K,ttm,end.s.milstein)
     }
     else(end.milstein.bs[i]=5)     
}

# discretized bs confidence intervals
exp(-r*ttm)*mean(end.euler.bs,na.rm=T)+qnorm(0.95)*sd(exp(-r*ttm)*end.euler.bs,na.rm=T)
exp(-r*ttm)*mean(end.euler.bs,na.rm=T)-qnorm(0.95)*sd(exp(-r*ttm)*end.euler.bs,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)+qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bs,na.rm=T)-qnorm(0.95)*sd(exp(-r*ttm)*end.milstein.bs,na.rm=T)

#************** validation code
rebate=5
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```


*(e) We improve the estimators in parts (c) and (d) by using an explicit formula for the probability of crossing the barrier. Give an estimate of the UOP option with a 95% confidence interval*

Using the formula as written, the barrier option estimate using discretized data is Euler: $6.2, Milstein: $6.7. The confidence intervals are below starting with Euler:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# function to calculate probability of knock-out
barrierProb=function(sigma,ttm,H,S_0,S_T){
     Q=exp(((2/sigma^2)/(ttm)) * log(H/S_0)*log(S_T/H))
}

# function to calculate black-sholes barrier put option value
barrierPutVal=function(sigma,r,ttm,K,H,S_0,S_T){
     pC=exp(-r*ttm)*(mean((K-S_T)[
          (1-barrierProb(sigma,ttm,H,S_0,S_T))>0]*
               (1-barrierProb(sigma,ttm,H,S_0,S_T))[(1-barrierProb(sigma,ttm,H,S_0,S_T))>0]))
     return(pC)
}

# get S_t from discretized paths
end.euler.bp=end.milstein.bp=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.euler.s)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.milstein.s)
}
sigma.ci=max(sd(end.euler.bp,na.rm=T),sd(end.milstein.bp,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bp=end.milstein.bp=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.euler.s)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.milstein.s)
}

# estimates and confidence intervals
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)+qnorm(0.95)*sd(end.euler.bp,na.rm=T)
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)-qnorm(0.95)*sd(end.euler.bp,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)+qnorm(0.95)*sd(end.milstein.bp,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)-qnorm(0.95)*sd(end.milstein.bp,na.rm=T)
```

*Show that this estimate is unbiased.*

While I can't show that this estimator is unbiased, it is close. The fExoticOptions barrier put price is $6.9. So, Euler misses by -10%. Milstein misses by -7%. 

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='hide',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

rebate=0
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```

*Is it different from the estimate in part (c)?*

The result is superior to my results in part "c". While higher than the benchmark, those missed by an average of +21%. This new approach misses by an average of -8.5%.

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

#************** implementation code
# function to calculate probability of knock-out
barrierProb=function(sigma,ttm,H,S_0,S_T){
     Q=exp(((2/sigma^2)/(ttm)) * log(H/S_0)*log(S_T/H))
}

# function to calculate black-sholes barrier put option value
barrierPutVal=function(sigma,r,ttm,K,H,S_0,S_T){
     pC=exp(-r*ttm)*(mean((K-S_T)[
          (1-barrierProb(sigma,ttm,H,S_0,S_T))>0]*
               (1-barrierProb(sigma,ttm,H,S_0,S_T))[(1-barrierProb(sigma,ttm,H,S_0,S_T))>0]))
     return(pC)
}

# get S_t from discretized paths
end.euler.bp=end.milstein.bp=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.euler.s)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.milstein.s)
}
sigma.ci=max(sd(end.euler.bp,na.rm=T),sd(end.milstein.bp,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bp=end.milstein.bp=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.euler.s)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutVal(sigma,r,ttm,K,H,S0,end.milstein.s)
}

# estimates and confidence intervals
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)+qnorm(0.95)*sd(end.euler.bp,na.rm=T)
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)-qnorm(0.95)*sd(end.euler.bp,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)+qnorm(0.95)*sd(end.milstein.bp,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)-qnorm(0.95)*sd(end.milstein.bp,na.rm=T)

#************** validation code
rebate=0
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```


*(f) Construct an estimator for the UOP option with rebate which is better than that in part (d). Is it biased low or high?*

The result is a Euler discretized estimate of $8.9 and a milstein discretized estimate of $9.5. The benchmark barrier with rebate estimate provided by fExoticOptions is $9.5. The new model estimates bracket the benchmark with an average error of -3%. So, collectively, the current estimates are biased low. However, the Milstein discretized estimate matches that provided by fExoticOptions. 

Confidence intervals for the two estimates are below beginning with Euler:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='hide',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

rebate=5

# function to calculate probability of knock-out
barrierProb=function(sigma,ttm,H,S_0,S_T){
     Q=exp(((2/sigma^2)/(ttm)) * log(H/S_0)*log(S_T/H))
}

# function to calculate black-sholes barrier put option value
barrierPutWRebateVal=function(sigma,r,ttm,K,H,S_0,S_T,rebate){
     pC=exp(-r*ttm)*(mean((K-S_T+rebate)[
          (1-barrierProb(sigma,ttm,H,S_0,S_T))>0]*
               (1-barrierProb(sigma,ttm,H,S_0,S_T))[(1-barrierProb(sigma,ttm,H,S_0,S_T))>0]))
     
     return(pC)
}

# get S_t from discretized paths
end.euler.bp=end.milstein.bp=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.euler.s,rebate)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.milstein.s,rebate)
}
sigma.ci=max(sd(end.euler.bp,na.rm=T),sd(end.milstein.bp,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bp=end.milstein.bp=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.euler.s,rebate)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.milstein.s,rebate)
}

# estimates and confidence intervals
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)+qnorm(0.95)*sd(end.euler.bp,na.rm=T)
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)-qnorm(0.95)*sd(end.euler.bp,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)+qnorm(0.95)*sd(end.milstein.bp,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)-qnorm(0.95)*sd(end.milstein.bp,na.rm=T)

# option price via fExoticOptions package
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```

\textbf{comments:}
Given that the revised formula is modifying the expected payout $K-S_T$ based on the original payout probability determined by the discretized monte carlo paths by the probability that the option is knocked-out, I simply need to change the value of the expected payout under these conditions to include the rebate amount $K-S_T+rebate$. 

\textbf{code:}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

rebate=5

# function to calculate probability of knock-out
barrierProb=function(sigma,ttm,H,S_0,S_T){
     Q=exp(((2/sigma^2)/(ttm)) * log(H/S_0)*log(S_T/H))
}

# function to calculate black-sholes barrier put option value
barrierPutWRebateVal=function(sigma,r,ttm,K,H,S_0,S_T,rebate){
     pC=exp(-r*ttm)*(mean((K-S_T+rebate)[
          (1-barrierProb(sigma,ttm,H,S_0,S_T))>0]*
               (1-barrierProb(sigma,ttm,H,S_0,S_T))[(1-barrierProb(sigma,ttm,H,S_0,S_T))>0]))
     
     return(pC)
}

# get S_t from discretized paths
end.euler.bp=end.milstein.bp=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.euler.s,rebate)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.milstein.s,rebate)
}
sigma.ci=max(sd(end.euler.bp,na.rm=T),sd(end.milstein.bp,na.rm=T));#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.bp=end.milstein.bp=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     s.discret.milstein=discret_milstein(S0,r,sigma,ttm,path.len)
     
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.milstein.s=s.discret.milstein[length(s.discret.milstein)]
     
     end.euler.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.euler.s,rebate)
     end.milstein.bp[i]=exp(-r*ttm)*barrierPutWRebateVal(sigma,r,ttm,K,H,S0,end.milstein.s,rebate)
}

# estimates and confidence intervals
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)+qnorm(0.95)*sd(end.euler.bp,na.rm=T)
exp(-r*ttm)*mean(end.euler.bp,na.rm=T)-qnorm(0.95)*sd(end.euler.bp,na.rm=T)

exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)+qnorm(0.95)*sd(end.milstein.bp,na.rm=T)
exp(-r*ttm)*mean(end.milstein.bp,na.rm=T)-qnorm(0.95)*sd(end.milstein.bp,na.rm=T)

# option price via fExoticOptions package
StandardBarrierOption(TypeFlag="puo", S=S0, X=K, H=H, K=rebate, Time=ttm, r=r, b=r, sigma=sigma)

```


*(g) Given the stock is a CEV process, take $\beta= âˆ’0.8$ and $\alpha$ such that $\alpha S_0^\beta = 0.3$. Use the Euler discretization scheme to generate sample paths. Consider an UOP without rebate, one could use the estimator in part (c). There is however a way of reducing the bias by saying that between two dicretization times, the CEV process can be approximated by a geometric Brownian motion. Then, use the formula given in expression of q(ti, x, ti+1, y) to compute an approximate value for the probability that the barrier is crossed between two dicretization times.*

*Give an estimate of the price together with a 95% confidence interval.*

I approached this from two directions. First, Using Euler discretization, a CEV process and the approach from (c), the estimated barrier put (no rebate) value is $7.6. The result is +10% of the benchmark estimate provided by fExoticOptions and an improvement of the +16% error seen in (c) using Euler with Black-Scholes. The 95% confidence intervals are below:

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# function to calculate cev put option value based on path of underlying
cevPutVal=function(sigma,r,alpha,div,K,ttm,S0,S_T,beta){
     
     v=((sigma^2)/
          (2*(r-div)*(alpha-1))) *
          (exp(2*(r-div)*(alpha-1)*(ttm))-1)
     
     a=((K*exp(-(r-div)*ttm))^(2*beta)) /
          ((beta)^2*v)
     
     b=1/(1-beta)
     
     c_parm=(S_T^(-2*beta))/(((beta)^2)*v)
     
     if(beta>-1 && beta<0){
          # adding barrier put probability adjustement to cev formula
               pC = ((K*exp(-r*ttm) * (pchisq(c_parm,b,a))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(a,b+2,c_parm))))
               
     } else if(beta>0){
               pC = ((K*exp(-r*ttm) * (pchisq(a,2-b,c_parm))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(c_parm,-b,a))))
     }
     return(pC)
}

# looping to find sigma.ci and, therefore, N.ci
end.euler.cev=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.cev[i]=cevPutVal(sigma,r,alpha,div,K,ttm,S0,end.s.euler,beta)
     }
     else(end.euler.cev[i]=0)   
}
sigma.ci=sd(end.euler.cev,na.rm=T);#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.cev=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.cev[i]=cevPutVal(sigma,r,alpha,div,K,ttm,S0,end.s.euler,beta)
     }
     else(end.euler.cev[i]=0)   
}

# discretized bs estimates
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)+qnorm(0.95)*sd(end.euler.cev,na.rm=T)
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)-qnorm(0.95)*sd(end.euler.cev,na.rm=T)

```

Second, I also tried modifying cev to include the barrier probability estimates per (e), but did not have time to incorporate the inter-discretization geometric Brownian modification. The resulting $5.9 estimate was inferrior to the estiamtes from (e).

```{r eval=TRUE,cache=TRUE,echo=FALSE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

# given
beta=-0.8
alphaS_0beta=0.3
alpha=0.3/(S_0^beta)

# function to evaluate put using cev process
cevPutWBarrierVal=function(sigma,r,alpha,div,K,H,ttm,S0,S_T,beta){
     
     v=((sigma^2)/
          (2*(r-div)*(alpha-1))) *
          (exp(2*(r-div)*(alpha-1)*(ttm))-1)
     
     a=((K*exp(-(r-div)*ttm))^(2*beta)) /
          ((beta)^2*v)
     
     b=1/(1-beta)
     
     c_parm=(S_T^(-2*beta))/(((beta)^2)*v)
     
     if(beta>-1 && beta<0){
          # adding barrier put probability adjustement to cev formula
          if((1-barrierProb(sigma,ttm,H,S0,S_T))>0){
               pC = ((K*exp(-r*ttm) * (pchisq(c_parm,b,a))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(a,b+2,c_parm)))) *
                    (1-barrierProb(sigma,ttm,H,S0,S_T))
          }else pC=NA
               
     } else if(beta>0){
          if((1-barrierProb(sigma,ttm,H,S0,S_T))>0){
               pC = ((K*exp(-r*ttm) * (pchisq(a,2-b,c_parm))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(c_parm,-b,a)))) *
                    (1-barrierProb(sigma,ttm,H,S0,S_T))}
          else pC=NA
     }
     return(pC)
}

# euler discretization
end.euler.cev=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.euler.cev[i]=exp(-r*ttm)*cevPutWBarrierVal(sigma,r,alpha,div,K,H,ttm,S0,end.euler.s,beta)
}
sigma.ci=sd(end.euler.cev,na.rm=T);#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.cev=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     end.euler.s=s.discret.euler[length(s.discret.euler)]     
     end.euler.cev[i]=exp(-r*ttm)*cevPutWBarrierVal(sigma,r,alpha,div,K,H,ttm,S0,end.euler.s,beta)
}

# estimates and confidence intervals
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)+qnorm(0.95)*sd(end.euler.cev,na.rm=T)
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)-qnorm(0.95)*sd(end.euler.cev,na.rm=T)

```

\textbf{code}
```{r eval=FALSE,cache=FALSE,echo=TRUE,message=FALSE,results='markup',warning=FALSE,fig.show='asis',fig.height=4,fig.width=7}

#*********** approach 1
# function to calculate cev put option value based on path of underlying
cevPutVal=function(sigma,r,alpha,div,K,ttm,S0,S_T,beta){
     
     v=((sigma^2)/
          (2*(r-div)*(alpha-1))) *
          (exp(2*(r-div)*(alpha-1)*(ttm))-1)
     
     a=((K*exp(-(r-div)*ttm))^(2*beta)) /
          ((beta)^2*v)
     
     b=1/(1-beta)
     
     c_parm=(S_T^(-2*beta))/(((beta)^2)*v)
     
     if(beta>-1 && beta<0){
          # adding barrier put probability adjustement to cev formula
               pC = ((K*exp(-r*ttm) * (pchisq(c_parm,b,a))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(a,b+2,c_parm))))
               
     } else if(beta>0){
               pC = ((K*exp(-r*ttm) * (pchisq(a,2-b,c_parm))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(c_parm,-b,a))))
     }
     return(pC)
}

# looping to find sigma.ci and, therefore, N.ci
end.euler.cev=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.cev[i]=cevPutVal(sigma,r,alpha,div,K,ttm,S0,end.s.euler,beta)
     }
     else(end.euler.cev[i]=0)   
}
sigma.ci=sd(end.euler.cev,na.rm=T);#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.cev=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     
     if(max(s.discret.euler)<55){
          end.s.euler=s.discret.euler[length(s.discret.euler)]
          end.euler.cev[i]=cevPutVal(sigma,r,alpha,div,K,ttm,S0,end.s.euler,beta)
     }
     else(end.euler.cev[i]=0)   
}

# discretized bs estimates
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)+qnorm(0.95)*sd(end.euler.cev,na.rm=T)
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)-qnorm(0.95)*sd(end.euler.cev,na.rm=T)

#*********** approach 2
# given
beta=-0.8
alphaS_0beta=0.3
alpha=0.3/(S_0^beta)

# function to evaluate put using cev process
cevPutWBarrierVal=function(sigma,r,alpha,div,K,H,ttm,S0,S_T,beta){
     
     v=((sigma^2)/
          (2*(r-div)*(alpha-1))) *
          (exp(2*(r-div)*(alpha-1)*(ttm))-1)
     
     a=((K*exp(-(r-div)*ttm))^(2*beta)) /
          ((beta)^2*v)
     
     b=1/(1-beta)
     
     c_parm=(S_T^(-2*beta))/(((beta)^2)*v)
     
     if(beta>-1 && beta<0){
          # adding barrier put probability adjustement to cev formula
          if((1-barrierProb(sigma,ttm,H,S0,S_T))>0){
               pC = ((K*exp(-r*ttm) * (pchisq(c_parm,b,a))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(a,b+2,c_parm)))) *
                    (1-barrierProb(sigma,ttm,H,S0,S_T))
          }else pC=NA
               
     } else if(beta>0){
          if((1-barrierProb(sigma,ttm,H,S0,S_T))>0){
               pC = ((K*exp(-r*ttm) * (pchisq(a,2-b,c_parm))) -
                          (S_T*exp(-div*ttm) * (1-pchisq(c_parm,-b,a)))) *
                    (1-barrierProb(sigma,ttm,H,S0,S_T))}
          else pC=NA
     }
     return(pC)
}

# euler discretization
end.euler.cev=NULL
for(i in 1:100){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     end.euler.s=s.discret.euler[length(s.discret.euler)]
     end.euler.cev[i]=exp(-r*ttm)*cevPutWBarrierVal(sigma,r,alpha,div,K,H,ttm,S0,end.euler.s,beta)
}
sigma.ci=sd(end.euler.cev,na.rm=T);#sigma.ci

## calculate N.ci: for 95% confidence interval using two-stage procedure
alpha.ci=0.05
N.ci=(sigma.ci^2/alpha.ci^2)*(qnorm(1-(alpha.ci/2))^2);#N.ci

end.euler.cev=NULL
for(i in 1:N.ci){
     s.discret.euler=discret_euler(S0,r,sigma,ttm,path.len)
     end.euler.s=s.discret.euler[length(s.discret.euler)]     
     end.euler.cev[i]=exp(-r*ttm)*cevPutWBarrierVal(sigma,r,alpha,div,K,H,ttm,S0,end.euler.s,beta)
}

# estimates and confidence intervals
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)+qnorm(0.95)*sd(end.euler.cev,na.rm=T)
exp(-r*ttm)*mean(end.euler.cev,na.rm=T)-qnorm(0.95)*sd(end.euler.cev,na.rm=T)

```
